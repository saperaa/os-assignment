Assignment 2: Basic forks and C Style Development
Lab 5 - Process Management Explanations
========================================

EXERCISE 1: Using fork() in C
-------------------------------
File: process_creation.c

What it does:
This program uses fork() to create a new process. When you call fork(), it makes a copy of the current process. The original is called parent, and the new one is child.

How fork() works:
- fork() returns different values:
  * In child process: returns 0
  * In parent process: returns the child's PID
  * If it fails: returns -1

- The code checks the return value:
  * If pid == 0, it's the child process
  * If pid > 0, it's the parent process
  * Otherwise fork failed

- Both processes run at the same time after fork()
- Each process has its own PID (Process ID)

Key points:
- PID = Process ID, unique number for each process
- getpid() gives you the current process PID
- fork() creates an exact copy of the parent's memory


EXERCISE 2: Starting Processes in Background
----------------------------------------------
Command: sleep 300 &

What it does:
The & at the end runs the command in the background. This means you can keep using the terminal while the process runs.

- sleep 300 = process that waits 300 seconds
- & = run in background
- jobs = shows all background jobs


EXERCISE 3: Stopping Processes
--------------------------------
Commands: ps aux | grep sleep, kill <PID>

What it does:
- ps aux = shows all running processes
- grep sleep = filters to show only processes with "sleep" in the name
- kill <PID> = stops the process with that PID

Steps:
1. Find the PID using: ps aux | grep sleep
2. Kill it using: kill <PID>
3. Check again: ps aux | grep sleep (should be gone)


EXERCISE 4: Pause and Resume
------------------------------
Commands: kill -STOP <PID>, kill -CONT <PID>

What it does:
- kill -STOP <PID> = pauses the process (doesn't kill it, just stops it)
- kill -CONT <PID> = resumes the paused process

This is useful when you want to pause something temporarily without killing it.


EXERCISE 5: Role of the Linker
-------------------------------
Files: file1.c, file2.c

What it does:
This shows how the linker works. We have two separate files that need to be combined.

file1.c:
- Has the hello() function definition
- Actually implements the function

file2.c:
- Has the hello() function declaration (just says it exists)
- Has main() which calls hello()

How linker works:
1. Compiler compiles each .c file separately into .o files
2. Linker combines the .o files into one executable
3. Linker finds where hello() is defined and connects it to where it's called

Without linker, file2.c wouldn't know where hello() is. The linker matches them up.

Compilation steps:
- Preprocessing: handles #include and macros
- Compilation: C code -> assembly code
- Assembly: assembly -> machine code (.o files)
- Linking: combines .o files and fixes references


EXERCISE 6: Role of the Loader
--------------------------------
File: simple_program.c

What it does:
Simple program that prints a message. Shows how loader loads programs into memory.

How loader works:
When you run a program (like ./simple_program), the loader:
1. Reads the executable file from disk
2. Loads it into memory
3. Loads any shared libraries it needs (like libc.so)
4. Sets up memory layout (code, data, stack, heap)
5. Starts the program

ldd command:
- Shows what shared libraries (.so files) the program needs
- Shows where each library is located
- Common ones: libc.so (C library), ld-linux.so (loader itself)

Dynamic vs Static linking:
- Dynamic: libraries loaded at runtime (smaller files, shared)
- Static: libraries included in executable (bigger files, but no dependencies)


========================================
WHAT IS THE JOB OF THE LINKER?
========================================

The linker is a program that combines multiple .o files into one executable.

Main jobs:
1. Symbol Resolution:
   - Finds where functions are defined
   - Connects function calls to their definitions
   - Makes sure everything is defined somewhere

2. Relocation:
   - Fixes memory addresses
   - Updates references to use correct addresses

3. Library Linking:
   - Links static libraries (.a files) by copying code
   - Sets up dynamic libraries (.so files) to load at runtime

4. Creates Executable:
   - Makes the final executable file (ELF format on Linux)
   - Sets up headers and entry point

The linker runs after compilation. It makes sure all the pieces fit together.


========================================
WHAT IS THE JOB OF THE LOADER?
========================================

The loader is part of the OS that gets programs ready to run.

Main jobs:
1. Loading:
   - Reads executable from disk
   - Puts it in memory
   - Understands the file format (ELF on Linux)

2. Dynamic Libraries:
   - Loads .so files the program needs
   - Finds symbols in libraries
   - Maps libraries into memory

3. Memory Setup:
   - Sets up virtual memory
   - Code section (read-only)
   - Data section (read-write)
   - Stack and heap

4. Address Resolution:
   - Fixes addresses
   - Sets entry point

5. Start Program:
   - Sets up arguments and environment
   - Calls main()

The loader runs when you execute a program. It works with the kernel to set everything up before your program starts running.
